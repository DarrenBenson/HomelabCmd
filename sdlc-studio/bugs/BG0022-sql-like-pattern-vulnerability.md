# BG0022: SQL LIKE Pattern Vulnerability in Alert Search

> **Status:** Fixed
> **Severity:** Critical
> **Priority:** P1
> **Reporter:** Claude (Code Review)
> **Assignee:** Claude
> **Created:** 2026-01-27
> **Updated:** 2026-01-27

## Summary

The `alerting.py` service uses `Alert.title.contains(service_name)` which generates SQL LIKE patterns without escaping special characters. An attacker could craft a service name containing `%` or `_` wildcards to match unintended alerts or extract data.

## Affected Area

- **Epic:** General infrastructure
- **Story:** N/A (Security bug)
- **Component:** Backend Services / Alerting

## Environment

- **Version:** Current main
- **Platform:** All
- **Browser:** N/A (Backend service)

## Reproduction Steps

1. Create a service with name `%admin%`
2. Query alerts for that service
3. Observe that ALL alerts containing "admin" anywhere are returned
4. Pattern `%` matches any sequence of characters in SQL LIKE

## Expected Behaviour

Service names should be escaped before being used in LIKE patterns:
- `%` should become `\%` (literal percent)
- `_` should become `\_` (literal underscore)

Or use exact matching where appropriate.

## Actual Behaviour

Service names are passed directly to `.contains()` which generates:
```sql
WHERE title LIKE '%<service_name>%'
```

If `service_name` is `%admin%`, the query becomes:
```sql
WHERE title LIKE '%%admin%%'
```

This matches any alert with "admin" anywhere in the title.

## Screenshots/Evidence

Code locations in `backend/src/homelab_cmd/services/alerting.py`:
- Line 458: `Alert.title.contains(service_name)`
- Line 531: `Alert.title.contains(service_name)`

## Root Cause Analysis

SQLAlchemy's `.contains()` method generates a LIKE pattern but does not escape SQL wildcards in the input string. This is documented behaviour but requires manual escaping or using the `autoescape=True` parameter.

## Fix Description

Used SQLAlchemy's built-in `autoescape=True` parameter on `.contains()` calls:

```python
# Before (vulnerable)
Alert.title.contains(service_name)

# After (fixed)
Alert.title.contains(service_name, autoescape=True)
```

The `autoescape=True` parameter automatically escapes `%` and `_` wildcards so they are treated as literal characters.

### Files Modified

| File | Change |
|------|--------|
| `backend/src/homelab_cmd/services/alerting.py` | Added `autoescape=True` to 2 `.contains()` calls (lines 458, 531) |
| `tests/test_alerting.py` | Added 3 regression tests for wildcard escaping |

### Tests Added

| Test ID | Description | File |
|---------|-------------|------|
| TC-BG0022-01 | Verify % in service name does not match wildcards | `tests/test_alerting.py` |
| TC-BG0022-02 | Verify _ in service name does not match wildcards | `tests/test_alerting.py` |
| TC-BG0022-03 | Verify resolving alerts with wildcards only resolves exact match | `tests/test_alerting.py` |

## Verification

- [x] Fix verified in development
- [x] Regression tests pass (1500 tests passing)
- [x] No side effects observed
- [ ] Documentation updated (if applicable)

**Verified by:** -
**Verification date:** -

## Related Items

| Type | ID | Description |
|------|-----|-------------|
| - | - | - |

## Notes

This is a security vulnerability, not just a bug. While not SQL injection (SQLAlchemy prevents that), it allows:
1. Information disclosure (matching more alerts than intended)
2. Potential denial of service (expensive queries with many wildcards)

Should audit all uses of `.contains()`, `.startswith()`, `.endswith()` for similar issues.

## Revision History

| Date | Author | Change |
|------|--------|--------|
| 2026-01-27 | Claude | Bug reported from code review |
| 2026-01-27 | Claude | Status → In Progress, began investigation |
| 2026-01-27 | Claude | Status → Fixed, added autoescape=True to .contains() calls |
